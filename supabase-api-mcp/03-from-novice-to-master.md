_Author: Joker_

# Serena 從新手到精通：一份完整的學習路徑指南

歡迎來到 Serena 的世界！本指南將帶您從一位對 Serena 毫無概念的新手，一步步成長為能夠靈活運用其所有強大功能的專家。我們將學習路徑劃分為五個等級，每個等級都建立在前一個的基礎之上，並解鎖新的技能與應用場景。

## Level 1: 觀察者 (The Observer) - 像專家一樣閱讀程式碼

在成為一名強大的程式碼編輯者之前，您必須先學會如何高效地「閱讀」和「理解」程式碼。在第一級，我們將專注於 Serena 的非破壞性、唯讀工具，讓您在不修改任何一行程式碼的情況下，獲得對專案的深度洞察。

### 核心目標

- 熟悉專案的檔案結構。
- 快速定位特定程式碼片段與符號定義。
- 理解程式碼之間的依賴與引用關係。

### 關鍵工具與實踐

| 工具 | 實踐任務 | 目標 | 
| :--- | :--- | :--- | 
| `list_dir` | 列出專案的根目錄和 `src` 目錄的內容。 | 掌握專案的整體檔案結構。 | 
| `read_file` | 閱讀 `package.json` 或 `pom.xml` 等專案設定檔。 | 了解專案的依賴和基本設定。 | 
| `find_symbol` | 尋找一個核心函式 (例如 `main` 或 `App`) 的定義。 | 學習如何從入口點開始追蹤程式碼。 | 
| `get_symbols_overview` | 取得一個主要檔案 (例如 `server.js`) 的符號概覽。 | 快速掌握一個檔案的職責與結構。 | 
| `find_referencing_symbols` | 找出一個重要的設定變數 (例如 `DATABASE_URL`) 在哪些地方被使用。 | 進行初步的影響力分析。 | 

> **通關挑戰：** 在不使用 IDE 的情況下，僅透過 Serena 工具，畫出一張核心功能 `A` 的函式呼叫鏈圖，從前端請求開始，一直追蹤到後端資料庫查詢。將您的發現記錄在一個名為 `call_chain_analysis.md` 的檔案中。

## Level 2: 編輯者 (The Editor) - 精準的程式碼手術

在掌握了閱讀程式碼的藝術之後，您將開始學習如何進行精準、安全的修改。這個階段的重點是使用 Serena 的編輯工具來完成一些常見的開發任務，例如修復 bug、添加小功能或更新設定。

### 核心目標

- 在不破壞現有程式碼結構的情況下，進行小規模的修改。
- 學習使用基於行號和符號的插入與取代工具。
- 建立對 Serena 編輯能力的信心。

### 關鍵工具與實踐

| 工具 | 實踐任務 | 目標 |
| :--- | :--- | :--- |
| `insert_at_line` | 在一個檔案的頂部添加一個新的 `import` 語句。 | 學習如何在指定位置精準插入程式碼。 |
| `replace_lines` | 修改一個設定檔中的資料庫連接字串。 | 練習取代單行或多行內容。 |
| `insert_before_symbol` | 在一個函式定義前，添加一段註解來解釋其功能。 | 學習在符號的邊界進行操作。 |
| `insert_after_symbol` | 在一個類別的最後，添加一個新的方法。 | 擴展現有模組的功能。 |
| `delete_lines` | 刪除一段不再需要的舊程式碼或註解。 | 進行安全的程式碼清理。 |

> **通關挑戰：** 找到一個簡單的 bug (例如，一個錯誤的變數名稱或一個錯誤的條件判斷)。使用 `read_file` 和 `find_symbol` 定位 bug，然後使用 `replace_lines` 或 `replace_content` 來修復它。最後，使用 `execute_shell_command` 運行測試，確保您的修復是正確的。

## Level 3: 重構者 (The Refactorer) - 程式碼庫的藝術性重塑

您現在已經具備了精準修改程式碼的能力。在第三級，您將學習如何進行更大規模、更結構化的程式碼重構。這不僅僅是修改，而是改善程式碼的設計、可讀性和可維護性，同時不改變其外在行為。

### 核心目標

- 安全地執行跨檔案的程式碼變更。
- 利用 Serena 的語義理解能力來進行複雜的重構任務。
- 提升程式碼庫的整體品質。

### 關鍵工具與實踐

| 工具 | 實踐任務 | 目標 |
| :--- | :--- | :--- |
| `rename_symbol` | 將一個在多個檔案中被使用的函式或類別重新命名。 | 體驗語義重構的威力，避免手動尋找取代的風險。 |
| `replace_symbol_body` | 將一個複雜函式的主體替換為一個更簡潔、更高效的實作。 | 在不影響呼叫者的情況下，優化內部邏輯。 |
| `find_referencing_symbols` + `replace_lines` | 手動模擬一個「提取變數」的重構：找到一個重複出現的魔法數字 (magic number)，將其定義為一個常數，然後取代所有使用到該數字的地方。 | 深入理解重構的步驟，並練習組合使用多個工具。 |

> **通關挑戰：** 執行一次「提取方法」(Extract Method) 的重構。首先，在一個冗長的函式中，識別出一塊可以被獨立出來的邏輯。然後，使用 `create_text_file` 或 `insert_after_symbol` 建立一個新的函式，將這段邏輯移入其中。最後，使用 `replace_lines` 將原始位置的程式碼替換為對新函式的呼叫。驗證所有測試是否依然通過。

## Level 4: 架構師 (The Architect) - 跨模組的功能建構

您已經是程式碼的雕塑家，現在是時候成為建築的設計師了。在第四級，您將學會跳脫單一檔案或符號的限制，從整個專案的宏觀視角來思考和操作。您將設計並實作橫跨多個檔案和模組的新功能。

### 核心目標

- 規劃並執行需要多步驟、跨檔案的複雜任務。
- 像人類開發者一樣，使用 shell 指令與專案的建置工具、版本控制和測試框架互動。
- 利用 Serena 的記憶體功能來管理複雜任務的上下文。

### 關鍵工具與實踐

| 工具 | 實踐任務 | 目標 |
| :--- | :--- | :--- |
| `write_memory` / `read_memory` | 在開始一個複雜功能前，先用 `write_memory` 寫下您的實作計畫。在每個步驟中，用 `read_memory` 來提醒自己下一步該做什麼。 | 學習如何規劃和執行多步驟的開發任務。 |
| `execute_shell_command` | 使用 `npm test` 或 `mvn test` 來運行專案的測試套件。 | 將 Serena 與專案的標準開發流程整合。 |
| `execute_shell_command` | 使用 `git status` 和 `git diff` 來檢查您透過 Serena 所做的變更。 | 學習如何驗證您的工作成果。 |
| 組合應用 | 組合使用 `create_text_file`, `insert_at_line`, `insert_after_symbol` 等多個工具來建立一個全新的功能模組。 | 練習從無到有地建構程式碼。 |

> **通關挑戰：** 從零開始實作一個新的 API 端點 (endpoint)。您的任務需要：
> 1.  使用 `create_text_file` 建立一個新的 controller 檔案和一個新的 service 檔案。
> 2.  在 router 檔案中，使用 `insert_at_line` 添加一個新的路由規則，指向您的新 controller。
> 3.  在 controller 中，實作處理請求的函式，並呼叫 service 中的商業邏輯。
> 4.  在 service 中，實作核心的商業邏輯。
> 5.  最後，使用 `execute_shell_command` 運行一個 `curl` 指令或一個測試腳本，來驗證您的新端點是否正常運作。

## Level 5: 自動化大師 (The Automation Master) - 將 Serena 變成您的 AI 開發夥伴

恭喜您來到最後一級！在這裡，您將超越「使用」工具的層次，開始「指揮」工具。您將學習如何將 Serena 的所有能力結合起來，自動化完成端到端的開發任務，使其成為一個能獨立思考和執行任務的 AI 開發夥伴。

### 核心目標

- 設計並撰寫能夠驅動 Serena 自動完成複雜任務的提示 (Prompt)。
- 學習使用 Serena 的「思考」工具來引導其決策過程。
- 將 Serena 從一個「工具」轉變為一個「自主代理」(Autonomous Agent)。

### 關鍵工具與實踐

| 工具 | 實踐任務 | 目標 |
| :--- | :--- | :--- |
| `think_about_task_adherence` | 在一個長任務的提示中，定期要求 Serena 使用此工具來檢查自己是否偏離了主要目標。 | 學習如何讓 AI 保持專注。 |
| `think_about_collected_information` | 當任務需要從多個檔案收集資訊時，要求 Serena 在分析後使用此工具，以判斷資訊是否齊全。 | 訓練 AI 進行更全面的思考。 |
| `think_about_whether_you_are_done` | 在您的提示的最後，明確要求 Serena 在宣告任務完成前，必須使用此工具進行最終檢查。 | 建立一個可靠的任務完成驗收機制。 |
| 自然語言指令 | 撰寫一個完整的自然語言指令，要求 Serena 完成一個端到端的任務，例如「分析 `X` 模組的性能瓶頸，找出最耗時的函式，並嘗試對其進行優化」。 | 練習如何將您的開發意圖，轉化為 AI 可以理解和執行的指令。 |

> **通關挑戰：** 您的最終挑戰是，讓 Serena 為自己添加一個新工具！這個任務極具挑戰性，需要您綜合運用前面學到的所有技能：
> 1.  **規劃:** 撰寫一個詳細的自然語言提示，指導 Serena 如何為自己添加一個名為 `get_project_version` 的新工具，該工具的功能是讀取 `package.json` 並回傳 `version` 欄位。
> 2.  **理解:** Serena 需要首先使用 `read_file` 和 `find_symbol` 來理解現有工具是如何被定義和註冊的。
> 3.  **編寫:** Serena 需要使用 `create_text_file` 或 `insert_after_symbol` 來建立一個新的工具定義檔案，並在主工具列表中註冊它。
> 4.  **驗證:** Serena 需要使用 `execute_shell_command` 來重新啟動自己，然後嘗試呼叫新的 `get_project_version` 工具，以驗證其是否成功。

完成這個挑戰，代表您已經真正掌握了與 AI 開發代理協作的藝術，歡迎來到軟體開發的未來！
